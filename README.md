# Решение

## Форматирование ввода в массив

Для нахождения строк в том, что ввёл пользователь я использовал regex, ведь мне не хотелось использовать сырую обработку текста. В итоге у меня получилась функция arr_from_str(), которая принимает введённый пользователем текст, а также то, что разделяет строки между собой, по умолчанию это пробел. Возвращает эта функция массив строк. Получился довольно интерсный паттерн - **[^(sep)]+**, где sep - это разделитель строк (это не прямо то, что есть в коде, он немного упрощён для его разбора). Скобки указывают, что другие операции проводятся на нескольких символах подряд, вместе, а не по отдельности. ^ указывает, что символы после этого оператора не должны быть взяты. Квадратные скобки указывают на какой-то тип символа, что писан в них. Плюс говорит о том, что надо взять вместе в одну строку символы до того момента, когда символ не будет подходить условиям.

## Решение самой задачи

У меня получилась функция limit_to_x_chars(), которая принимает на вход массив строк, а также количество символов, которое допустимо. Возвращает эта функция тоже массив строк. Сначала она создаёт масств строк размером с входной массив строк (чтобы в любых случаях всё вместилось), над которым будут проводиться операции и в итоге функция его отдаст на выход.
```
string[] result_arr = new string[str_arr.Length];
```
Также из-за того, что мне нужно использовать массивы, необходимо знать самый ранний незанятый индекс, который у меня репрезентирован так:
```
int result_arr_occupied = 0;
```
Дальше цикл for, который проходит по всем индексам массива на входе. Ещё дальше условие, которое проверяет, какое количество символов в определённой строке входного массива, если количество больше или равно лимиту количества, то в новый массив добавляется на самой ранней незанятой позиции эта самая строка. Таким образом получается, что в новом массиве не будет тех строк, которые не удовлетворяют требованиям.
```
if (str_arr[i].Length <= limit) {
  result_arr[result_arr_occupied] = str_arr[i];
  result_arr_occupied++;
}
```
А потом новый массив возвращается.

## Другое

Мне хотелось сделать всё с помощью функций, ведь в конце связующие операции выглядят лаконично, даже красиво:
```
string arr_input = Console.ReadLine();
string[] formatted_array = limit_to_x_chars(arr_from_str(arr_input), 3);
Console.WriteLine(string.Join(" ", formatted_array));
```
